


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter {Parallel Black Virus Decontamination in Chordal Ring}
\label{TL}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
 

\section{Introduction}
In this chapter, we discuss a parallel strategy for  BVD problem in chordal rings. A chordal ring is a circulant graph with $d_1=1$, i.e., it is an augmented ring, and will be denoted by $C_n(1, d_2, ..., d_k)$. More specifically, in chordal ring each node is directly connected to the nodes at distance $d_i$ by additional links called chords. The link connecting two nodes is labeled by the distance that separates these two nodes on the ring. (see Fig.\ref{fig:chordalring})
 
\begin{figure}[H]
  \centering  
  \includegraphics[width=3in]{figures/chordalring.png}
  \caption{An example of chordal ring $C_n(1,4)$}\label{fig:chordalring}
\end{figure}

%For convenience, if we say the agents or the clones move along chord $i$, then they actually move along $d_i$. If we say the agents or the clones move $i$, then they actually move along chord $d_x$ with its length equal to $i$. 
Agents are anonymous, but for the purpose of easier description,  we refer to the nodes as $x_0$,  $x_1$ \dots.
Agents are not allowed to communicate with each other unless they are in the same node so the protocol should enable agents in different nodes to move properly. That is, the route of every agent is different but they are served to explore the network; when a BV is triggered, other agents should bypass the new-formed BVs. We give simple but efficient solution to deal with the problem with acceptable cost. 
%Let us denote by $d$ the half degree of the chordal ring (for example, for the chordal ring structure $C_n(1,2,4,5)$, $d=4$), by $l$ the length of the longest chord of the chordal ring (for example, for the chordal ring structure $C_n(1,2,4,5)$, $l=5$). 
%{\bf d and l are already defined as $k$ and $d_k$ why change ? Use the same terminology throughout}
Our goal is to minimize the time to complete the whole decontamination process and at the same time the casualties. In order to do that, we propose a parallel strategy for decontaminating the chordal ring and this is the first attempt to deal with this issue in a parallel way. 
%
%Since time cost in the elimination phase is negligible comparing to the exploring phase if $n$ is large enough, it would be much simple to execute the elimination sequentially. That is, instead of destroy all the clones at the same time, we decontaminate them on by one. Also, in the elimination phase, in order to save the number of agents, we chase all the $Keep\,Moving$ agents (explained in section Surrounding and Elimination) back.
% It is obvious that it may cost some time for this process. If  the execution time is of great important to us and we care less the number of agents we employ, then we may carry enough agent at the beginning and start the elimination phase right after the exploring phase. 
% 

%In this Chapter we describe a single parallel strategy for the shadowed exploration phase, we then propose several different strategies for the elimination phase, each with its own advantages and disadvantages:  
%1) chasing back the $Keep\,Moving$ agents and decontaminating the BVs sequentially 
%2) chasing back the $Keep\,Moving$ agents and decontaminating the BVs parallelly 
%3) start to decontaminating the BVs right after the exploring phase and do it parallelly 
%4) start to decontaminating the BVs right after the exploring phase and do it parallelly. The cost of each strategy including time, number of agents, casualties would be analyzed in the section Analysis and Comparing.

\section{Shadowed Exploration}
\noindent{\bf Initialization }\\
The chordal ring is a complete symmetrical structure, so we can randomly choose a node $x_0$ as the start node.  The initial setup consists of deploying three groups of agents.
Initially, we place one  agent in each of the first $2d$ nodes   $x_0, x_1, \ldots , x_{2d-1}$. 
The agents residing in nodes from $x_0$ to $x_{d-1}$ form the  {\em shadowing group}, while the ones from $x_d$ to $x_{2d-1}$ form the {\em exploring group}. 
If the BV is within this window of nodes, then it is easily detected. We then assume that the  first $2d$ nodes do not contain the BV, and we place $d$ additional agents at nodes $x_ 0,x_1, \ldots, x_{d-1}$ ({\em guarding group}). 
Only the shadowing and exploring groups move to explore the graph. The ones in the guarding group remain dormant for now, guarding the nodes to guarantee monotonicity. 

\noindent{\bf Route of the agent in exploring phase}\\
The exploration proceeds in synchronized rounds composed each by  one movement step, when selected groups of agents move to proceed with the exploration, and three steps for synchronization purposes. We call these different steps {\em move step}  and  {\em notification steps}. A round $T_i$ is composed by four time units, one for the move step, and 3 for the notification steps:$T_1 = T_{move\_1},T_{noti\_1^{(1)}},T_{noti\_1^{(2)}},T_{noti\_1^{(3)}},  T_2 = T_{move\_2},T_{noti\_2^{(1)}},T_{noti\_2^{(2)}},T_{noti\_2^{(3)}}$,\ldots

% 
%
%$T_{move\_1}$, 
%$T_{notice\_1}$, 
%$T_{notice\_1'}$, 
%$T_{notice\_1''}$, $T_{move\_2}$, $T_{notice\_2}$, $T_{notice\_2'}$, $T_{notice\_2''}$ ...
%
%More specifically, every cycle contains one unit of time for moving and three units of time for notice. We discuss why we arrange the time as above and what exactly the agents do in the notice time later. 
The agents that move during a move step $T_{move\_i}$, always do so along their longest chord $d_k$. That is, agents move along $d_k$ in steps $T=1+4t$ $(t\in \mathbb{N})$.  
An example of how agents move in chordal ring $C_n(1, 2 , 4, 5)$ at $T_{move\_i}$ in the  exploring phase is shown in Fig.\ref{fig:subfig1}. \\

\begin{figure} [H]
  \centering 
  \subfigure[Arrangement of agents at $T_{move\_i}$]{ 
    \label{fig:subfig1:a} %% label for first subfigure 
    \includegraphics[width=3.0in]{figures/chordal_a_l.png}} 
  \hspace{1in} 
  \subfigure[Arrangement of agents at $T_{move\_{i+1}}$]{ 
    \label{fig:subfig1:b} %% label for second subfigure 
    \includegraphics[width=3.0in]{figures/chordal_a1_l.png}}
  \caption{Arrangement of agents when moving} 
  \label{fig:subfig1} %% label for entire figure 
\end{figure}

\noindent{\bf Synchronization: Three\,Jump\,Notifying\,Technique}
In the sequential strategy \cite{alotaibi},  two agents explore the graph (exploring agent and leader agent)  using  ``cautious walk". That is, the Exploring Agent moves to the next node in its route, and if the node is safe, it moves back to the Leader Explorer Agent, and then move forward to that safe node together. If instead the node contains a BV, the Leader Explorer Agent becomes aware of that because a BV arrives through that link instead of Explorer Agent. 
However, in our strategy, we employ $2d$ agents in the exploring phase but we do not use the ``casual walk". We then have to guarantee that they all find out whether or not the BV has been found in the current round. In fact, if they are not properly informed, when one agent is destroyed by the BV, in their next step some of them (the risky agents RAs) may be destroyed by the new formed BVs. In order to avoid these potential casualties, we propose the $Three\,Jump\,Notifying\,Technique$ to properly notify the agents who otherwise would move to the new formed BVs in the next round.\\

The idea is the following: when/if a node receives a clone and becomes aware of the presence of the BV,  it becomes a  $Notification\,Agent$ (NA). The NA's role is to make the risky agents aware of the presence of the BV in an efficient way. They will do so in parallel, each following  a special  route of length 3.  More precisely, let the BV be at node $x_0$ (refer to Figure \ref{fig:subfig}), the $Notification\,Agent$ located at node $x_{n-d_i}$ will follow the following route:

$x_{n-d_i}\xrightarrow [] {move\,along\,chord\,d_i}x_0\xrightarrow [] {move\,along\,chord\,d_k}x_{n-d_k}\xrightarrow []{move\,along\,chord\,d_i}x_{n-d_k+d_i}$.
 
 In this case, the notifying route of the $NA$ whose coordinate is $x_{n-d_k}$ is $x_{n-d_k}{\rightarrow}x_0{\rightarrow}x_{-d_k}{\rightarrow}x_0$.
 
Note that with the $Three\,Jump\,Notifying$ technique, we only inform the RAs (agents who will be destroyed by the BV next step)(i.e., agents residing in nodes $x_{n+d_i-d_k}$, $(i=1,\ldots, d_{k-1})$) but still, agents (if existing) residing in node $x_{n+d_i-2d_k}$, $(i=1,\ldots, d_{k-1})$ will be destroyed by the BVs in their next two moves. So they should be properly informed as well. 

Actually, this could be easily performed: when one agent $A1$ moves to a node where there is an agent $A2$ knowing the position of the original BV, $A1$ would be informed and directly moves along the longest chord to its own position. 

In this way, all the agents that might be destroyed by the BV would be properly informed.
 
 {\bf confusion between node, chord, etc. Let us always use $x_i$ for the nodes (not $i$), $d_i$ for the chords, etc..}
 
 We would make some modification of this agents route in the $Surrounding\,and\,Elimination$, but now let us assume it still follows the route above. The whole process of  $Three\,Jump\,Notifying$ technique in chordal ring $C_n(1, 2, 4, 5)$ is shown in Fig.\ref{fig:subfig}. \\

%
%To explain it more clearly, let us make an example  in a chordal ring $C_n(1, d_2, \ldots,  d_k)$, assuming  for convenience that $x_0$, in this case,  corresponds to the  node containing the original BV.
%If  the   BV is triggered, its  clones  spread to nodes whose coordinates are $-d_k$, $-d_{k-1}$, \ldots, $-d_2$, $-1$, $1$, $d_2$, \ldots, $d_{k-1}$, $d_k$. 
%After a move step then, there is a risk that these nodes   are contaminated; the goal of the $Three\,Jump\,Notifying\,Technique$ 
%is to notify the agents which are supposed to move there next (the $Risky\,Agent$ ($RA$s) )   to actually stop. 
%The coordinates of the $Risky\,Agent$ ($RA$s) are $1- d_k$, $d_2-d_k$, \ldots, $d_{k-1}-d_k$, $d_k-d_k$ (which is exactly the coordinate of the original BV) respectively. It is obvious that not all of the nodes from $1$ to $d_k$ become BV nodes after the triggering because there might be some agents already there, but since notifying all the $Risky\,Agents$ does not add more cost comparing to notifying some of them, in our strategy, we notify all of the $RA$s. 


\begin{figure} [H]
  \centering 
  \subfigure[Arrangement of agents at $T_{move\_i}$]{ 
    \label{fig:subfig:a} %% label for first subfigure 
    \includegraphics[width=2.5in]{figures/tjt1.png}} 
  \hspace{1in} 
  \subfigure[Arrangement of agents at $T_{noti\_i^{(1)}}$]{ 
    \label{fig:subfig:b} %% label for second subfigure 
    \includegraphics[width=2.5in]{figures/tjt2.png}} \
  \hspace{1in} 
  \subfigure[Arrangement of agents at $T_{noti\_i^{(2)}}$]{ 
    \label{fig:subfig:c} %% label for second subfigure 
    \includegraphics[width=2.5in]{figures/tjt3.png}} 
  \hspace{1in} 
  \subfigure[Arrangement of agents at $T_{noti\_i^{(3)}}$]{ 
    \label{fig:subfig:d} %% label for second subfigure 
    \includegraphics[width=2.5in]{figures/tjt4.png}} 
  \caption{The whole process of the $Three\,Jump\,Notifying$ technique in chordal ring $C_n(1, 2, 4, 5)$} 
  \label{fig:subfig} %% label for entire figure 
\end{figure}




If the original BV is residing in the red node, then once an agent moves to it, the agent and the BV are destroyed but the clones of the BV spread to all its neighbours. According to our technique, 
%nodes whose coordinates are $1$, $2$, $4$, $5$ become $Possible\,BV\,Nodes$; 
agents residing in nodes $x_{-4}$, $x_{-3}$, $x_{-1}$, $x_0$ are the  ones to be notified; 
agents residing in nodes $x_{-5}$, $x_{-4}$, $x_{-2}$, $x_{-1}$ are the $NA$s.
 The routes for agents residing in nodes $x_{-5}$, $x_{-4}$, $x_{-2}$, $x_{-1}$ are $x_{-5}{\rightarrow}x_0{\rightarrow}x_{-5}{\rightarrow}x_0$; $x_{-4}{\rightarrow}x_0{\rightarrow}x_{-5}{\rightarrow}x_{-1}$; $x_{-2}{\rightarrow}x_0{\rightarrow}x_{-5}{\rightarrow}x_{-3}$; $x_{-1}{\rightarrow}x_0{\rightarrow}x_{-5}{\rightarrow}x_{-4}$ respectively.\\

\noindent{\bf Safe Exploring with Three\,Jump\,Notifying technique}

After the initialization, the exploring and shadowing agents move   following the longest chord. The subsequent three time units are either used for the notification phase (if one of the agents is destroyed at  time $T_{move\_i}$), or they are spent simply by waiting before the next move.
If  executing the $Three\,Jump\,Notifying$ technique,  the $NA$s move  back to where they are before the notification. For example, in the example in $Three\,Jump\,Notifying$ technique, $NA$ residing in node $-1$ moves back to node $x_{-4}$ following the reverse route in the notifying phase which is $x_{-1}{\rightarrow}x_{-5}{\rightarrow}x_0{\rightarrow}x_{-4}$. 

\section{Surrounding and Elimination}
 When a BV is found,  the Three\,Jump\,Notifying technique   guarantees that the risky agents are now aware of the presence of the BV. Other agents, however, might not have received the notification and might proceed to the next round without such knowledge; we call these agents $KeepMoving$ agents.   

In this section, we introduce the process of eliminating the BVs after the original BV is triggered. For the purpose of saving the number of agents, we prefer to chase the $Keep\,Moving$ agents, but it is not necessary to complete the process especially when you care most about the  execution time; In that case, we may  instead  carry enough agents  and  proceed to the $Surrounding\,and\,Elimination$ phase immediately. 
The number of agents that should be carried in order to successfully proceed the $Surrounding\,and\,Elimination$ will be discussed later.  We now describe how to chase the $KeepMoving$ agents.

\subsection{Notifying Moving Agents}

\noindent{\bf Overview of the Notifying Moving Agents}

When the $Shadowed\,Exploring$ ends, it is possible that some of the agents in the array are not informed and do not realize the existence of the BV, so they keep moving following the routes in $Shadowed\,Exploring$  phase but it is obvious that they would not encounter any BV. In order to reduce waste, we employ the agent who receives the clone from chord $d_k$ ($Coordinator\,Agent$) to notify the other $Keep\,Moving$ agents to move back to their   position  they occupied before the BV was triggered.
% Now we introduce how we choose the $Coordinate\,Agent$($CA$)and how the $CA$ notifies the other agents.\\

\noindent{\bf The Process of the Notifying Phase of the Coordination Agent}

To do that we employ one of the agents as a  $Coordinator\,Agent$($CA$). The CA follows a specific path that will guarantee to meet all the $Keep\,Moving$ within a certain amount of rounds.


The general outline of the technique is the following:
\begin{enumerate}
\item the CA is chosen to be the agent who receives a BV clone from its longest chord. %once the $Three\,Jump\,Notifying$ technique is terminated,
%\item the CA moves to occupy an arbitrary node within a special range $[y,z]$ (the rules of moving and the range computation are described later) once selected.
\item following three moving rules (the rules of moving are described later) the CA moves to occupy an node as the starting point for chasing and set a notification window $[x_y,x_z]$ (the range computation are described later) based on its own coordinate. 
\item the CA waits an appropriate amount of time to allow the agents that are still moving to reach this window of nodes
\item the CA now moves in synchronization with the movement of the agents and follows a specific paths. 
More precisely, while the moving agents proceed as usual  with one move and 3 waiting steps, the CA will take its longest chord in correspondence of an agents move and 3 consecutive nodes in correspondence of the waiting steps of the moving agents. In doing so, with $O(d_k)$ moves, the CA is guaranteed to have encountered  all of them.
\item when a moving agent encounters the CA, it stops and waits for a second agent that will arrive at the next round. When both agents are there, they go back to their original positions to start the surrounding phase.
\end{enumerate}


For   convenience,  we consider the chordal ring as arranged in rows of size $d_k$ where the last node of a row is connected to the first node of the following row and the last node is connected to the first. Depending on the size of the chordal ring, the last row could be incomplete. So in this matrix, moving down a column corresponding to using the longest chord $d_k$.(see Fig.\ref{fig:matrix}). 
\begin{figure}[H]
  \centering  
  \includegraphics[width=0.6\textwidth]{figures/matrix.png}
  \caption{Viewing a chordal ring whose longest chord is 11 as a matrix}\label{fig:matrix}
\end{figure}

In the following step, we would use a concept called ``Notification Window". In a chordal ring $C_n(1, d_2, \ldots, d_k)$, given a coordinate $x$, the $Notification\,Window$ $[x_{y},x_{z}]$   contains  a set of consecutive nodes where   $x_{y}$ is   the $Beginning\,Flag$ and   $x_{z}$ is   the $End\,Flag$. When we mention ``marking a flag", it does not mean that the agent has to move to the node to do that but only needs to remember the positions of the two flags in its memory.
The relations between $x$, $x_{y}$, $x_{z}$ is defined   as follows: 
\begin{itemize}
\item $x_{y}$ is the biggest number   smaller than or equal to $x_i$ and  such that   $x_{y}$ mod $d_k$ =$0$; 
\item $x_{z}$ is the smallest number s bigger than $x_i$ and that $x_{z}$ mod $d_k$ = $d_{k-1}$.
\end{itemize} 

For example, in the matrix of  Figure \ref{fig:matrix}), given a node, the $Beginning\,Flag$ of its ``Notification Window" is the first node of its row while the $End\,Flag$ is the last node of its row.

The selection of the $CA$ is simple: when an agent receives a BV clone from its longest chord, then it realizes that it is chosen as the $CA$. More specifically, if the coordinate of the original BV is $x_i$, then the coordinate of the CA would be $x_{i-d_k}$.
After being selected as the CA, the CA should move to a node as the starting point for chasing. In the matrix, if the original BV reside in row $i$, then the destination of the $CA$ (the starting point for chasing) should be in any node in row $i+2$ to avoid being destroyed by the clones when chasing the ``Keep\,Moving" agents. In this case, the $Notification\,Window$ set by the $CA$ would be from $x_{d_k\times(i+2)}$ to $x_{d_k\times(i+2) + d_{k}-1}$.
%In this case, the chasing phase starts from $T_{move\_{i+2}}$ assuming the time when the BV is triggered is $T_{move\_i}$, which means the chasing phase begins only after all the $Keep\,Moving$ agents move twice after the BV being triggered. At $T_{move\_{i+2}}$, all the $Keep\,Moving$ agents are in a 


Supposing the coordinate of the original BV is $x_i$ ,the coordinates of the positions where the clones spread are: $x_{i-d_k}$ (which is the original coordinate of the $CA$), $x_{i-d_{k-1}}$, $x_{i-d_{k-2}}$, \ldots, $x_{i-1}$, $x_{i+1}$, $x_{i+d_2}$, \ldots, $x_{i+d_{k-1}}$, $x_{i+d_{k}}$. There are three different situations to consider to describe the behavior of the CS.  
Now we describe the  three scenarios:
\begin{itemize}
\item Scenario 1: The last agent of the $Exploring\,Group$ is destroyed by the BV and the positions of the clones satisfy: $x_{i-d_{k-1}+d_{k}}=x_{i+1}$, $x_{i-d_{k-2}+d_{k}}=x_{i+d_2}$, \ldots, $x_{{i-1}+d_{k}}=x_{i+d_{k-1}}$. 
\item Scenario 2: The last agent of the $Exploring\,Group$ is destroyed by the BV and the at least   pair of the positions of the clones does not satisfy: $x_{i-d_{k-1}+d_{k}}=x_{i+1}$, $x_{i-d_{k-2}+d_{k}}=x_{i+d_2}$, \ldots, $x_{{i-1}+d_{k}}=x_{i+d_{k-1}}$. 
\item Scenario 3: One of the agents in the $Exploring\,Group$ except the last agent is destroyed by the BV.
\end{itemize}

In scenario 1, the $CA$ needs to move for 5 steps to reach its destination while in the other two scenarios, it only needs to move for 4 steps to arrive the destination. Now we describe the route for each scenario.
\begin{itemize}
\item For $CA$ in scenario 1: Let us denote by $x_i$ the coordinate of the node in the $Notification\,Window$ set by the coordinate of the original BV which does not receive any clone and his left neighbour receives a clone (the coordinate of which is $x_{i-1}$). The $CA$ first moves to the original BV, then to node $x_{i-1}$, finally to $x_i$. At this point, it only needs to move along   chord $d_k$   twice to reach its destination.
\item For $CA$ in scenario 2: There is at least one pair of   positions of the clones that does not satisfy the equations, so there should be one node (say, $x_i$) who receives a clone from the original BV but node $x_{i+d_k}$ is empty. The route now for the $CA$ is first to move to the original BV, then to node $x_i$, and then   along the chord $d_k$   twice to reach its destination.
\item For $CA$ in scenario 3: The $CA$ here simply needs to move   one step to its right neighbour and move along the chord $d_k$   three times to reach its destination.
\end{itemize}

The $Keep\,Moving$ agents reach the $CA$'s $Notification Window$ 8 unit of time after the BV is triggered. Because it takes at most 6 units of time for the $CA$ to reach its destination, the $CA$ need to wait  for the $Keep\,Moving$ agents before beginning the chasing. The $CA$ simply counts the time it costs to reach its destination (say. $t$), and compute the time it need to wait which is $8-t$.
%In any case, the $CA$ can reach its destination within 6 unit of time which is required for  
%,and let us donate it by $Initial\,Notification\,Window$. The $CA$ would directly move to any node in $Initial\,Notification\,Window$. Now we propose three kinds of routes for the $CA$ to move to his destination:
%We can see that the relative position of agents does not change when they keep moving along the longest chord. For example, agents residing in nodes 1, 5, 10 (noted as $A1$, $A5$, $A10$) move along the longest chord and then $A5$ moves forward for one step. Their relative position  would be exactly the same as the situation where all of them remain dormant except $A5$ moves forward for one step. 
%Now we discuss how the $CA$ notify all the $Keep\,Moving$ agents assuming they are dormant and then make some modification to fit the scenario where the $CA$ notifies the $Keep\,Moving$ agents. The problem we need to solve is that given a range within which the agents are in and a $CA$ located in this range, let the $CA$ to notify all the agents in this range. 
The chasing phase starts from $T_{move\_{{i+2}^{(1)}}}$. The ``Keep Moving" agents proceed with one move and three waiting steps while the $CA$ takes its longest chord in correspondence of an agent's move and three consecutive nodes in correspondence of the waiting steps of the ``Keep Moving" agents. Every time when the $CA$ moves along  a chord $d_k$, it resets the ``Notification Window" as below: 

$New\,Beginning\,Flag=Old\,Beginning\,Flag+d_k$

$New\,End\,Flag=Old\,End\,Flag+d_k$

When the $CA$ moves along three consecutive nodes, it notifies the agents it encounters (if any) to go back. To ensure that the $CA$ and the ``Keep Moving" agents are in the same ``Notification Window", during the movement of the $CA$,   when it realizes that it just passes the $End\,Flag$, the $CA$ should move along the longest chord counter-clockwise to the node marked   $Beginning\,Flag$ and should continue to move   along three consecutive nodes to notify agents it encounters . The chasing phase terminates when the $CA$ arrives at a  node $x_y$ which satisfies $x_y=x_z+t\times{d_k}$ ($t\in \mathbb{N}$) (The relative starting point). 

\paragraph {\bf Example:} 
The route of the $CA$ in the chasing phase is shown for an example in Fig.\ref{fig:chasing} for a  chordal ring $C_n(1, 2, 7, 11)$. 
\begin{figure}[H]
  \centering  
  \includegraphics[width=1.0\textwidth]{figures/chasing.png}
  \caption{The route of the $CA$ in the chasing phase in a chordal ring C(1, 7, 11)}\label{fig:chasing}
\end{figure}
In this example, node $x_{61}$ is the starting point of the chasing phase and at this time, the ``Notification Window" is $[x_{55}, x_{65}]$.The $CA$ moves along three consecutive nodes $x_{62}$, $x_{63}$ and $x_{64}$ while the ``Keep Moving" agents are waiting and then move along the longest chord to node $x_{75}$. At this time, the $CA$ updates its ``Notification Window" to $[x_{66}, x_{76}]$. After that, it continues to move along three consecutive nodes, but when it arrives $x_{77}$, it realizes that it just passes the ``End Flag" which is $x_{76}$, so it moves along the longest chord  counter-clockwise to the node marked   $Beginning\,Flag$ which is $x_{66}$. After that, it moves along the longest chord with the ``Keep Moving" agents to $x_{77}$ and again updates its ``Notification Window", then moves along the nodes to notify the agents...

Let us assume that the time when the original BV is triggered is $T_{move\_i}$ , then the $CA$ should remember the $T_{move\_i}$ and informs the agents he encounters of it. The agent $A1$ who encounters the $CA$ should remember the time when they encounter ($T_{noti\_y^{(a)}}\,a\in(1,2,3)$) and stop moving until next $T_{move}$ ($T_{move\_{y+1}}$) when it will meet another agent $A2$. Then $A1$ moves along $d_k$ anticlockwise for $y+1-i$ times while $A2$ moves for $y+2-i$ times. 
When arriving its relative starting point at $T_{move\_a}$, the $CA$ knows that it has finished the chasing task and moves along $d_k$ to its position when the original BV is triggered.



We now describe how  the agents and the $CA$ move in coordination  in   $C_n(1, 2, 7, 11)$  (see Figure \ref{fig:T29}). 
\begin{figure}[H]
  \centering  
  \includegraphics[width=0.6\textwidth]{figures/T29.png}
  \caption{Arrangement of agent at $T_{move\_2}$ when the BV is triggered}\label{fig:T29}
\end{figure}

Yellow nodes are connected to the original BV but guarded by agents while   grey nodes are the new formed BVs. The node marked $V$ is the original BV is now clean. The agent residing in node $x_{29}$ receives a clone from chord $d_k$ so it knows it is the $CA$. During the notifying time, agents residing in nodes $x_{33}$, $x_{38}$, $x_{39}$ notify agents residing in nodes $x_{36}$, $x_{31}$, $x_{30}$ respectively following the $Three\,Jump\,Notifying\,Technique$,  while the $CA$ moves to $x_{28}$, $x_{39}$, $x_{50}$ and finally $x_{61}$ following the route in scenario 3.

\begin{figure}[H]
  \centering  
  \includegraphics[width=0.6\textwidth]{figures/T50.png}
  \caption{Agents' roles after $Three\,Jump\,Notifying\,Technique$. (for convenience, we denote the $CA$ by a red spot, more specifically, node $x_{50}$ is where $CA$ resides)}\label{fig:T50}
\end{figure}

Agents in purple nodes would be notified at $T_{move\_3}$ and move back. Agents in light green nodes are the $Keep\,Moving$ agents,  while agents in dark green nodes are informed to stop in $Three\,Jump\,Notifying\,Technique$. In the meantime, the $CA$ moves to node $x_{28}$, $x_{39}$, $x_{50}$, and finally $x_{61}$. It is obvious that the $CA$ can reach its destination before $T_{move\_4}$, so it waits until $T_{noti\_{4^{(1)}}}$ to start its notifying phase. 

\begin{figure}[H]
  \centering  
  \includegraphics[width=0.6\textwidth]{figures/T611.png}
  \caption{Arrangement of agent at $T_{move\_3}$. The $CA$ has arrived its destination}\label{fig:T611}
\end{figure}

\begin{figure}[H]
  \centering  
  \includegraphics[width=0.6\textwidth]{figures/T612.png}
  \caption{Arrangement of agents at $T_{move\_4}$. The $CA$ starts its chasing phase}\label{fig:T612}
\end{figure}

In the chasing phase, $CA$ starts to notify other $Keep\,Moving$ agents. First, it computes the $Notification\,Window$ which is from node $x_{55}$ to node $x_{65}$. It moves to node $x_{62}$ at $T_{noti\_4^{(1)}}$, node $x_{63}$ at $T_{noti\_4^{(2)}}$, node $x_{64}$ at $T_{noti\_4^{(3)}}$ and to node $x_{75}$ at $T_{move\_5}$. 

\begin{figure}[H]
  \centering  
  \includegraphics[width=0.6\textwidth]{figures/T75.png}
  \caption{Arrangement of agents at $T_{move\_5}$. }\label{fig:T75}
\end{figure}
After that, $CA$ moves to node $x_{76}$ at $T_{noti\_5^{(1)}}$. We can see that it encounters the agent residing in node $x_{76}$, so $CA$ informs node $x_{76}$ about the $T_{trigger}$, which is $T_{move\_2}$. {\em The agent residing in node $x_{76}$ should remember $T_{noti\_now}$ which is $T_{noti\_5^{(1)}}$ and wait additional time  $T_{move}$ to inform agent ($Following\,Agent$) who resides in node $x_{65}$ now but would move to node $x_{76}$ next $T_{move}$. } After encountering its $Following\,Agent$, the $CA$ informs it to move back along chord $d_k$ for $T_{move\_now}-T_{trigger} +1$ times which is $T_{move\_5}- T_{move\_2}+1$ times,  while it moves for $T_{move\_5}-T_{move\_2}$ times. 

At $T_{noti\_5^{(2)}}$, when the $CA$ arrives at node $x_{77}$, it knows that it just pass its $Ending\,Flag$ so it moves along the longest chord anticlockwise to its $Beginning\,Flag$ (node $x_{66}$ at $T_{noti\_5^{(3)}}$.
\begin{figure}[H]
  \centering  
  \includegraphics[width=0.6\textwidth]{figures/T66.png}
  \caption{Arrangement of agents at $T_{move\_5^{(3)}}$. }\label{fig:T66}
\end{figure}

\begin{figure}[H]
  \centering  
  \includegraphics[width=0.6\textwidth]{figures/T94.png}
  \caption{Arrangement of agents at $T_{move\_7^{(3)}}$. }\label{fig:T94}
\end{figure}

We could know that the $CA$ moves back to its relative starting point (node $x_{94}$) at $T_{noti\_7^{(3)}}$ and it knows that it has finished the chasing phase and moves back to its original starting point which is node $x_{29}$.


\subsection{Overview of the Elimination}
After all the agents move back to where they are when the BV is triggered, they start the $Surrounding\,and\,Elimination$ phase. 

The BVs can be destroyed sequentially,  which is simple,  but might be time consuming in some cases. In this way, because all the agents are aware of the positions of the new-formed BVs,   for each BV,  at most $d-1$ agents are sent to surround it  and one agent is sent to destroy. This elimination strategy has been used in \cite{alotaibi}. 

An alternative strategy, which allows a faster decontamination at the expense of a larger number of agents, is to  the BVs concurrently. First we need to guard all the neighbouring nodes of all the newly formed BVs. In order to avoid collision and efficiently leverage the agents, we allocate different Destination Tables to all the agents in the array to inform them where should they   move in different situations (e.g., when the first agent in the exploring team is destroyed, then every agent except the first agent have a distinct destination, when the second agent is destroyed, then every agent except that agent destroyed have again a distinct destination). More specifically, for a Chordal Ring with   degree $2k$, every agent in the array carries a $Destination\,Table$ with $k-1$ destinations. If we need more agents, then we   give their $Destination\,Table$ to the last agent in the shadowing group,. When the elimination begins, the agent clones a sufficient  number of agents and give   the    $Destination\, Table$ to them. 
Before moving to its destination, the agent computes the shortest route from its own position to its destination using Dijkstra Algorithm. There are two kinds of agent in the Elimination phase: {\em surrounding agents} that are responsible for guarding the neighbouring nodes of the BVs and {\em destroying agents} who move to the BVs after all the neighbouring nodes are guarded. We want the BVs to be destroyed at one time, so it is important that the destroying agents move to the BVs at the same time and only after all the neighboring nodes are guarded by agents. In fact, if the destroying agents know the longest time $t_{longest}$ to move to the destination taken by all the agents (including the destroying agents and the surrounding agents), then they can move to the last node prior to the destination and wait until time  $t_{longest}$ to move to the BVs simultaneously. So,  in the $Destination\,Tables$ for the destroying agents, we also add  the time   $t_{longest}$. We now  describe how to compute the shortest routes and how to design the $Destination\,Tables$. Note that we design $Destination\,Tables$ for all the agents and allocate them to the agents before the exploring phase begins.

\subsection{Destination Table and Elimination}
Suppose that there are some BVs and agents in the chordal ring, it is obvious that the BV nodes are in the clockwise side of the agents. In order to use Dijkstra, first we need to map the chordal ring with BVs into a graph where we would run the Dijkstra algorithm to find out the shortest route from every node to its destination.{\bf what do you mean by "map into a graph" ? The chordal ring is already a graph.}We include nodes from the node containing the first agent to the node which is $d_k$ away from the last BV node, then delete the chords from the BV nodes to build the graph where we run Dijkstra Algorithm.
Here is an example how we built the graph for running Dijkstra Algorithm. Below we show the situation when the third agent in the exploring group is destroyed by the BV (see Figure \ref{fig:D1}). Only the chords of the original BV node are shown. 
\begin{figure}[H]
  \centering  
  \includegraphics[width=0.6\textwidth]{figures/D1.png}
  \caption{Situation when the third agent in the exploring group is destroyed}\label{fig:D1}
\end{figure} 

The black node is the BV node while the green nodes need to be guarded. In this case, we need 12 agents (10 surrounding agents and 2 destroying agents). 
We add nodes from 13 to 33 with their chords within this area and delete chords connected with the BV nodes to get the graph where we use Dijkstra Algorithm. Below is the graph we build. (see Figure  \ref{fig:D2}). For convenience, we show   all the nodes we included and the chords we delete.
\begin{figure}[H]
  \centering  
  \includegraphics[width=0.6\textwidth]{figures/D2.png}
  \caption{The graph we build for Dijkstra Algorithm}\label{fig:D2}
\end{figure} 
Using the graph and Dijkstra Algorithm, we compute the routes from every agent to every node. Then we use enumeration to choose an allocation of every agents's destination considering that: 
\begin{description}
\item 1) the maximum length of the route should be minimum. 
\item 2) after the allocation, in every needed position there should be exactly one agent.
\end{description}

Eery agent in the exploring group should hold a $Destination\,Table$ of $d-1$ parts (Part $i$ records its moving information when $No.i$(anticlockwise) agent in the exploring group is destroyed) while   every agent in the shadowing group should hold a $Destination\,Table$ of $d$ parts. Note that an agent in the exploring group have only $d-1$ parts because tit does not need to record moving information when itself is destroyed. Besides, every part contains 1 items (for surrounding agents) or 2 items (for destroying agents). 

After we get the optimal allocation, we can know the destination of every agent when $No.i$ agent in the exploring group is destroyed and we can also know whether it is a surrounding agent or a destroying agent in the situation when $No.i$ agent is destroyed.

For each agent in the chordal ring, each item in Part $i$ of its $Destination\,Table$ is arranged as below. 
\begin{description}
\item 1) The first item records the agent's destination
\item 2) The second item records the longest time $t_{longest}$ among all agents.
\end{description}


After one of the agent is destroyed, the agent can check their $Destination\,Table$ to get the information of their destination. Then using Dijkstra Algorithm they can compute the shortest route separately and starts to move. The destroying agents should move to the last node prior to the destination and wait until $t_{longest}$ to move to the BVs together. 


\section{Analysis}

{\bf Paola: I added the new proof. This part is still to be checked.}

 \begin{theorem}
If the structure of a chordal ring is fixed, regardless of the position of the BV, the number of $Keep\,Moving$ agents is constant.
\end{theorem}
\begin{proof}


Define: Going column, the column in which the agents keep going when an explorer encounters a virus.\\
Define: Stop column, the column in which the agents stop moving when an explorer encounters a virus.
We assume that the structure of the ring is $C_n(d_1, \dots, d_{k-1}, d_k)$, and there are $k$ columns in the matrix which are $M={c_0, \dots, c_{k-1}}$\\
We assume the number of node where the original BV is $node_V$, then it should be in the column $c_{V\,mod\,k}$.\\
A column $c_S$ is a stop column if and only if $\exists i\in [1,k]$, so that $(V+d_i)\,mod\,k=S$ or $(V-d_i)\,mod\,k=S$.\\
If the explorer encounters the virus at the position $node_{V+a}$ instead of $node_V$, since $(V+d_i+a)\,mod\,k=(S+a)\,mod\,k$ or $(V-d_i+a)\,mod\,k=(S+a)\,mod\,k$, the column $c_{(S+a)\,mod\,d}$ should be a stop column.\\
In another word, if $c_S$ is a stop column when virus position is $V$, then $c_{(S+a)\,mod\,k}$ is a stop column when the virus position is $V+a$.\\
We assume we have two different stop columns $c_x$ and $c_y$ ($0\leq x\leq d-1$, $0\leq x\leq d-1$) when the black virus's position is $V$.  So when the black virus's position is $V+a$, the stop columns are $c_{(x+a)\,mod\,k}$ and $c_{(y+a)\,mod\,k}$. It is obvious that $\forall a$, if $x\neq y$, then $(x+a)\,mod\,d\neq(y+a)\,mod\,d$. That means we still have two different stop columns. So that the number of stop column does not decrease, which means that given a fixed chordal ring $C$ and the number of agent keeping moving when the BV is in V (V can be any position), then the number of agent keeping moving when the BV is in other position does not decrease.\\
Let us assume that the number of agents keeping moving in different case when the longest chord remains the same is different and denotes the minimum number of going columns among them by $N_{minimum}$ while the maximum number of going columns among them by $N_{maximum}$, then according to our conclusion $N_{minimum}\geq N_{maximum}$, which means that $N_{minimum}= N_{maximum}$ . In another word, the number of agents keeping moving is fixed when the structure of the chordal ring is fixed. 
\end{proof}

 

 
 
\noindent{\bf Time cost analysis and Comparisons}

We only consider the situation when $n$ (the number of nodes of the chordal ring) is much larger than $d_k$, and since the time cost in the elimination phase is $O(1)$, we only compute the time cost in the exploring phase. Finally, we compute the TWT(calculated by multiplying the size of the team and the time cost by the solution) {\bf Add reminder of TWT? }of both protocols to present a more fair comparison.

Let us assume that the total number of moves is $M$, then the worst case costing the most time is when the BV is located at any nodes within the range from $x_{n-d_k+1}$ to $x_{n-1}$. In this case, it cost $M=\left \lfloor 2n-2d_k\right \rfloor$ moves and 4$\frac{M}{2d_k}$ units of time which is $4\times \left \lfloor \frac{n}{d_k}-1\right \rfloor$ to finish the exploring phase. 
In \cite{alotaibi}, she give the number of move in three case.
\begin{itemize}
\item 1) In double loops the upper bound of moves is $4n-7$.
\item 2) In the triple loops, she discusses two classes of chordal ring: $C_n(1,p,k)$ and $C_n(1,d_k-1,d_k)$.In the first case, the number of moves needed is $5n-6d_k+22$ while in the second case, a maximum of $5n-7d_k+22$ moves are needed.
\item 3) In the consecutive-chordal rings, a maximum of $(d_k+2)n-2d_k-3$ moves are needed.
\end{itemize}
Since in the sequential strategy, agents do not need to wait so the time cost is equal to the number of moves. And it is obvious that our protocol is much faster than the sequential strategy. But since we use much more agents, so in order to gain a fair comparison, now we compute TWT of both protocol.

In the exploring phase, we use $2d_k$ agents, so the TWT of our protocol is $8n-8d_k$. In the exploring phase of the sequential strategy, it need at least 2 agent to explore and some other shadow agents to guard the explored nodes but the number of shadow depends on the structure of the chordal ring so now we ignore them. Now we compute TWT of the sequential strategy.
\begin{itemize}
\item 1)In double loops the upper TWT is $8n-14$
\item 2)The TWT in chordal ring $C_n(1,p,d_k)$ is $10n-6d_k+44$ and in chordal ring $C_n(1,d_k-1,d_k)$ is $10n-14d_k+44$.
\item 3)The TWT in consecutive-chordal rings is $2(d_k+2)n-4d_k-6$.
\end{itemize}
It is obvious that when $d_k\geq 2$, our protocol is faster in first case; when $d_k\leq \frac{1}{3}n+7$,our protocol is faster in the second case (both $C_n(1,p,k)$ and $C_n(1,d_k-1,d_k)$); when $d>2-\frac{1}{n+2}$, our protocol is faster in the third case.

\noindent{\bf Casualy Analysis}

Casualty is the number of agents destroyed by the BV. In chordal ring $C_n(1, d_2,\dots, d_k)$, the worst case is that the first agent in the exploring group is destroyed by a BV and the clones of it spread to all its neighbouring nodes. The casualties in this case are $d_k+1$ because another $d_k$ nodes are guarded by agents while in sequential case, the casualties are $2d_k$. So in terms of casualty, our protocol is better than the sequential strategy.






